API guidelines
==============

- Provide an easy API that provides multiple streams over a single connection

- The exact SPDY functionality and protocol details are not exposed to the
  application. Usage of this API shall require no intimate knowledge of SPDY.

- Transport layer agnostic. Spindly functions read from and send to memory
  buffers to allow the application to send/recv data in whatever way it thinks
  is fine

- No global data, everything thread-safe

- Keep internal data/structs private and hidden from the app

- Try make the API work for multiple SPDY protocol versions

Handling of the "physical" connection
=====================================

CONN = spindly_phys_init(SIDE, PROTVER)

  Create a handle for a single duplex connection, SIDE is either client or
  server - what side the handle is made to handle. PROTVER is the specific
  SPDY protocol version.

RESULT = spindly_phys_incoming(CONN, DATA, DATALEN);

  when the application has read data off the transport, this function is
  called to tell Spindly about more data that has arrived. As spindly doesn't
  read any network data by itself, it needs to get the data passed into it by
  the application.

  After data has been fed into the handle, call spindly_phys_demux() to make
  it demux the incoming data.

RESULT = spindly_phys_demux(CONN, &DEMUX)

  Returns information about incoming data on the connection, split up for
  consumption accordingly. Subsequent calls will return the next result and so
  on until there's nothing left to demux - until spindly_phys_incoming() is
  called again to feed it with more data. Not that when it returns that there
  is no more message, it may still hold trailing data that forms the beginning
  of the subsequent message.

  If RESULT is OK, DEMUX will tell which message that was received

  SPINDLY_DX_NONE - no more (complete) message in the struct, demux more!
 
  SPINDLY_DX_GOAWAY - shut down the entire CONN. See spindly_phys_cleanup()

  SPINDLY_DX_STREAM_ACK - a previous call to spindly_stream_new() has been
    acked and the associated STREAM struct can be used/extracted now

  SPINDLY_DX_STREAM_REQ - a request for a new stream from the peer was
    received and you should ack or nack it. see spindly_stream_ack() and
    spindly_stream_nack()

  SPINDLY_DX_STREAM_KILL - a stream has been closed, the associated STREAM
    can no longer be used and should be closed. see spindly_stream_close()

  SPINDLY_DX_SETTINGS - one or more settings have been updated, some info
    about which settings that were updated needs to be provided.
    TODO: provide more help for serving/keeping persistent SETTINGS

  SPINDLY_DX_PING - a ping was received (and a response have been created
    in the output queue). This is for informational purposes only and there's
    no extra action required on the application's behalf.

  SPINDLY_DX_DATA - data arrived to a specific STREAM, see
    spindly_stream_recv()

  SPINDLY_DX_MDATA - meta-data arrived to a specific STREAM, see
    spindly_stream_recv_meta()

RESULT = spindly_phys_ready(CONN, &SEND);

  Will return info (pointer and length) about the data that CONN holds that is
  available to send over the transport medium immediately.

RESULT = spindly_phys_sent(CONN, LENGTH);

  Tell Spindly how many bytes of the data that has been sent and should be
  considered consumed. The CONN will then contain updated information of
  amount of remaining data to send etc.

RESULT = spindly_phys_settings(CONN, SETTINGS);

  Change one or more settings associated with the connection. This will result
  in a SPINDLY_DX_SETTINGS message to end up on the remote side.

void spindly_phys_cleanup(CONN);

  Cleanup the entire connection and all associated streams and data.


handle separate streams over the physical connection
====================================================

RESULT = spindly_stream_new(CONN, &STREAM, CUSTOMP);

  Creates a request for a new stream and muxes the request into the output
  connection, creates a STREAM handle for the new stream and returns the
  RESULT. The CUSTOMP pointer will be associated with the STREAM to allow the
  application to identify it.

  Note that the stream is not yet ready to be used until it has been
  acknowledged by the peer and we get a SPINDLY_DX_STREAM_ACK response.

RESULT = spindly_stream_ack(STREAM);

  The STREAM as requested to get opened by the remote is allowed!

RESULT = spindly_stream_nack(STREAM);

  The STREAM as requested to get opened by the remote is NOT allowed!

RESULT = spindly_stream_close(STREAM);

  Close the STREAM. Can be used as a response to a SPINDLY_DX_STREAM_KILL
  message or it will generate such a message to the other side.

RESULT = spindly_stream_recv(STREAM, &DATA);

  Receive specific data for this specific stream.

RESULT = spindly_stream_recv_mdata(STREAM, &DATA);

  Receive meta-data for this specific stream. Header/value pairs or flow
  control information (and more?)

RESULT = spindly_stream_send(STREAM, DATA, DATALEN);

  Send data on this specific stream.

RESULT = spindly_stream_send_mdata(STREAM, METADATA, LEN?);

  Send metadata on this specific stream.

RESULT = spindly_stream_window(STREAM, DELTA);

  TODO: Modify the WINDOW SIZE with DELTA ...


HTTP helpers
============

 uhm...


Utility functions
=================

RESULT = spindly_version(REQUIRED, &STRING)

  Returns the version number (as an integer) if it is of the REQUIRED version
  or better, and an error if not. STRING will then be a pointer to the version
  string.
